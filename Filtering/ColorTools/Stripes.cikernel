

// X: normalized x for luminance
// Y: normalized y for luminance
// S: saturation (HSL formula)
// L: lightness (HSL formula)
vec4 rgb2rgsl(vec3 c)
{
	float cmax = max(max(c.r, c.g), c.b);
	float cmin = min(min(c.r, c.g), c.b);
	float delta = cmax - cmin;
	float zeroGate = step(0., delta);
	float lx2 = (cmax + cmin);
	float s = delta / (1. - abs(lx2 - 1.));
	return zeroGate * vec4((c.rg - cmin) / delta, s, lx2 * 0.5);
}
float lightness(vec3 c)
{
	float cmax = max(max(c.r, c.g), c.b);
	float cmin = min(min(c.r, c.g), c.b);
	float lx2 = (cmax + cmin);
	return lx2 * 0.5;
}
float hsvsaturation(vec3 c)
{
	float cmax = max(max(c.r, c.g), c.b);
	float cmin = min(min(c.r, c.g), c.b);
	float C = (cmax - cmin);
	float V = cmax;
	return C / V;
}

float mixture(vec3 color, float redGreenMix, float mixPower, float saturationPower, float saturationThreshold)
{
	float redGreenFactor = dot(normalize(color.rg), vec2(1.0, -1.0));
	float blueFactor = clamp(dot(normalize(color), vec3(1., 0., -.2)), 0., 1.);
	vec4 rgsl = rgb2rgsl(color.rgb);
	float halfIntensity = sqrt(rgsl.w) * sqrt(1.-rgsl.w) * 2.;
//			float saturationFactor = (pow(rgsl.z, saturationPower) - saturationThreshold) * (1. - saturationThreshold);

	float mixture = clamp(redGreenMix * redGreenFactor, 0., 1.) * blueFactor * clamp(halfIntensity * 1.5, 0., 1.);
	return pow(mixture, mixPower);
}
// x: primary (red/green)
// y: opposing secondary (green/red)
// z: opposing tertiary (blue/blue)
float mixture2(vec3 values, float xyMix, float power, float zThreshold) {
	float xyFactor = clamp(dot(normalize(values.xy), vec2(1., -1.)), 0., 1.);
	float zFactor = clamp(zThreshold - 2. * normalize(values).z, 0., 1.);
	float light = lightness(values) * clamp(5. * (-0.02 + hsvsaturation(values)), 0., 1.);
	float mixture = clamp(xyMix, 0., 1.) * xyFactor * zFactor * clamp(4. * pow(light, 2.), 0.0, 1.0);
	return pow(clamp(mixture, 0., 1.), power);
}
float makePrimary(float mixValue) {
	float factor = 1.3;
	return clamp(mixValue * factor - (factor - 1.), 0.0, 1.0);
}

float redMix(vec3 color, float showRed) {
	return mixture(color, 1. * showRed, 1.8, .75, .0);
}
float redPrimaryMix(vec3 color, float showRed) {
	return makePrimary( mixture(color, 1. * showRed, 1.0, .75, .0));
	float redFactor = 1.6 *(1. - pow(0.7 * normalize(color).b - normalize(color).g, .4));
	return makePrimary(mixture(color, 1. * showRed, 1.0, .75, .0) * clamp(redFactor, 0., 1.));
}

float greenMix(vec3 color, float showGreen) {
	color = sqrt(max(color, 0.));
	return mixture2(color.grb, 1. * showGreen, 0.4, 2.0);
}
float greenPrimaryMix(vec3 color, float showGreen) {
	color = sqrt(max(color, 0.));
	return clamp(mixture2(color.grb, 1. * showGreen, 0.4, 1.3) * 1.4, 0., 1.);
}

float blueMix(vec3 color, float showBlue) {
	color = sqrt(max(color, 0.));
	return mixture2(.5*(color.brg + color.bgr), 1. * showBlue, 0.7, 2.0);
}
float bluePrimaryMix(vec3 color, float showBlue) {
	color = sqrt(max(color, 0.));
	return clamp(mixture2(.5*(color.brg + color.bgr), 1. * showBlue, 0.7, 3.3) * 1.4, 0., 1.);
}

float modDown(float a, float b) {
	return ((a/b) - floor((a/b))) * b;
}

kernel vec4 Stripes(sampler src, float showRed, float showGreen, float showBlue, float patternscale) {
	float stepBound = patternscale * 8.0;
	float blueStepBound = patternscale * 6.0;

	vec2 coord = destCoord();
	vec4 color = sample(src, samplerTransform(src, coord));
	// Mac has two stripe sizes
	float stepRed = modDown(showRed * (coord.y + coord.x), stepBound);
	float stepNonGreen = modDown(showGreen * (coord.y + coord.x), stepBound);
	float stepGreen = modDown(showGreen * (coord.y - coord.x), stepBound);
	float stepBlue = modDown(showBlue * (1. + coord.y), blueStepBound);

	// Red
	if (stepRed < patternscale)
	{
		// Shallow red
		vec3 stripeColor = vec3(1., 1., 1.);
		color.rgb = mix(color.rgb, stripeColor, redPrimaryMix(color.rgb, showRed));
	}
	else if (stepRed >= patternscale * 6.0 && stepRed < stepBound)
	{
		// Deep red
		vec3 stripeColor = vec3(0., 0., 0.);
		color.rgb = mix(color.rgb, stripeColor, redMix(color.rgb, showRed));
	}
	// Mac has two stripe sizes, can't use red pattern check for the dashes.
	if (stepNonGreen < patternscale) {}
	else if (stepNonGreen >= patternscale * 6.0 && stepNonGreen < stepBound) {}
	else // now insert green stripe checks
	// Green
	if (stepGreen < patternscale)
	{
		// Shallow green
		vec3 stripeColor = vec3(1., 1., 1.);
		color.rgb = mix(color.rgb, stripeColor, greenPrimaryMix(color.rgb, showGreen));
	}
	else if (stepGreen >= patternscale * 6.0 && stepGreen < stepBound)
	{
		// Deep green
		vec3 stripeColor = vec3(0., 0., 0.);
		color.rgb = mix(color.rgb, stripeColor, greenMix(color.rgb, showGreen));
	}
	// Blue
	if (stepBlue < patternscale)
	{
		// Shallow blue
		vec3 stripeColor = vec3(1., 1., 1.);
		color.rgb = mix(color.rgb, stripeColor, bluePrimaryMix(color.rgb, showBlue));
	}
	else if (stepBlue >= patternscale * 5.0 && stepBlue < blueStepBound)
	{
		// Deep blue
		vec3 stripeColor = vec3(0., 0., 0.);
		color.rgb = mix(color.rgb, stripeColor, blueMix(color.rgb, showBlue));
	}
	return color;
}
